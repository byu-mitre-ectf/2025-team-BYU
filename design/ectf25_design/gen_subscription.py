import argparse
import json
from pathlib import Path
import struct
from loguru import logger
from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto.Hash import Poly1305

def gen_subscription(
    secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate the contents of a subscription.
 
The output of this will be passed to the Decoder using ectf25.tv.subscribe
 
    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """

    # Load the json of the secrets file
    secrets = json.loads(secrets)
    
    # Concatenate DeviceID, StartTimeStamp, EndTimeStamp, Channel, and Channel Key
    # Pack device_id (unsigned int), start (unsigned long long), end (unsigned long long), and channel (unsigned int) into binary format (as per the design?)
    packed_numbers = struct.pack("<IQQI", device_id, start, end, channel)
    
    # Retrieve the channel key from secrets.
    # (This will likely need to be changed as I don't actually know how the secrets are stored...)
    channel_key = secrets["channel_keys"][str(channel)]

    # Append the channel key (converted to bytes) to the packed numbers
    source_message = packed_numbers + channel_key.encode()
    
    # Get RSA device private key from global secrets.
    # Assumes the RSA device private key is stored under the key "rsa_device_key" in PEM format
    # I looked at the decoder code for this and I **think** this is right, provided that the design doc is also correct
    rsa_priv_pem = secrets.get("rsa_device_key")
    rsa_key = RSA.import_key(rsa_priv_pem)
    
    # Convert the source message to a long integer (IS THIS NEEDED?)
    # When I gave my code to Chat to check for bugs and stuff this was literally the only thing it said and it was VERY convinced that I needed it
    m = bytes_to_long(source_message)
    
    
    # START CRYPTO :)    
    # TODO: Macen please check my crypto here
    
    
    # Encrypt source message using RSA private key.
    # (Performing RSA private-key operation: c = m^d mod n)
    c = pow(m, rsa_key.d, rsa_key.n)
    
    # Convert the result to bytes, padded to the RSA key size.
    rsa_output = long_to_bytes(c, rsa_key.size_in_bytes())
    
    # Get Poly1305 device key from global secrets.
    # Assumes the Poly1305 device key is stored under "poly1305_device_key" in the secrets file
    poly1305_key = secrets.get("poly1305_device_key")

    poly1305_key = poly1305_key.encode()  # Ensure it's in bytes as Poly1305 needs it
    
    # Compute Poly1305 MAC tag of the RSA output using the Poly1305 device key.
    mac_obj = Poly1305.new(key=poly1305_key)
    mac_obj.update(rsa_output)
    mac_tag = mac_obj.digest()
    
    
    # END CRYPTO :)
    
    
    # Append MAC to encrypted source message.
    final_subscription = rsa_output + mac_tag
 
    # Pack the subscription. This will be sent to the decoder with ectf25.tv.subscribe
    return final_subscription
 
 
def parse_args():
    """Define and parse the command line arguments
 
    NOTE: Your design must not change this function
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()
 
 
def main():
    """Main function of gen_subscription
 
    You will likely not have to change this function
    """
    # Parse the command line arguments
    args = parse_args()
 
    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )
 
    # Print the generated subscription for your own debugging
    # Attackers will NOT have access to the output of this (although they may have
    # subscriptions in certain scenarios), but feel free to remove
    #
    # NOTE: Printing sensitive data is generally not good security practice
    logger.debug(f"Generated subscription: {subscription}")
 
    # Open the file, erroring if the file exists unless the --force arg is provided
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)
 
    # For your own debugging. Feel free to remove
    logger.success(f"Wrote subscription to {str(args.subscription_file.absolute())}")
 
 
if __name__ == "__main__":
    main()