import argparse, struct, json
from Crypto.Cipher import ChaCha20_Poly1305
from Crypto.Random import get_random_bytes

class Encoder:
    def __init__(self, secrets: bytes):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """

        # Parse the JSON-formatted secrets file
        secrets = json.loads(secrets)
        
        # Store the channel keys from the secrets dictionary
        # This dictionary holds the keys for each channel
        self.channel_keys = secrets["channel_keys"]  

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

            This method is used for encoding the frames that need to be sent by the satellite.

            You **may not** change the arguments or returns of this function!
        
            Parameters:

                channel (int):  Channel number (unsigned 16-bit integer). Channel 0 is reserved for broadcast.
                frame: Frame data to encode. Maximum size is 64 bytes.
                timestamp:  Timestamp used for encoding (64-bit unsigned integer).

            Returns:
                bytes: Encoded frame, ready for transmission.
        """

        # Validate the inputs to ensure correct format
        if len(frame) > 64:
            raise ValueError("Frame size exceeds 64 bytes!")  # Frame cannot be larger than 64 bytes
        if not (0 <= channel <= 0xffffffff):
            raise ValueError("Channel number must be an unsigned 32 byte integer!") # Channel number must be within valid range
        if not (0 <= timestamp <= (2**64 - 1)):
            raise ValueError("Timestamp must be an unsigned long long integer!") # Timestamp must be within valid range

        # Create the packet from the timestamp and frame
        packet = struct.pack("<Q", timestamp) + frame

        # Ensure the channel has an associated key in the secrets data
        if str(channel) not in self.channel_keys:
            raise ValueError(f"No key found for channel {channel}!")

        # Convert the key for the given channel from hex string to bytes
        key = bytes.fromhex(self.channel_keys[str(channel)])

        # Generate a random 12-byte nonce for encryption (ChaCha20-Poly1305 requires a 12-byte nonce)
        nonce = get_random_bytes(12)

        # Create a ChaCha20-Poly1305 cipher object with the key and nonce
        cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)

        # Update the cipher with the channel number and nonce
        cipher.update(struct.pack("<I", channel) + nonce)

        # Encrypt the packet and generate the associated tag
        ciphertext, tag = cipher.encrypt_and_digest(packet)

        # Construct the final packet, which includes the channel number, nonce, tag, and ciphertext
        final_packet = struct.pack("<I", channel) + nonce + tag + ciphertext

        # Return the encoded frame (final packet)
        return final_packet

def parse_args():

    """Define and parse the command line arguments

        This function sets up and parses the required command-line arguments for
        encoding a TV frame.

        Returns:
            argparse.Namespace: Parsed command-line arguments.
    """

    # Create an argument parser instance
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")

    # Required argument: Path to the secrets file
    parser.add_argument(
            "secrets_file", 
            type=argparse.FileType("rb"), 
            help="Path to the secrets file"
        )

    # Required argument: Channel number
    parser.add_argument(
            "channel", 
            type=int, 
            help="Channel to encode for"
        )

    # Required argument: TV frame data
    parser.add_argument(
            "frame", 
            help="Contents of the frame"
        )

    # Required argument: Timestamp of TV frame
    parser.add_argument(
            "timestamp", 
            type=int, 
            help="64b timestamp to use"
        )

    # Parse and return the command-line arguments
    return parser.parse_args()

def main():
    """A test main to one-shot encode a frame

        This function is only for your convenience and will not be used in the final design.

        After pip-installing, you should be able to call this with:
            python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """

    # Parse the command-line arguments
    args = parse_args()
    
    # Initialize the Encoder object using the secrets file contents
    encoder = Encoder(args.secrets_file.read())

    # Encode the frame with the provided channel, frame, and timestamp
    encoded_frame = encoder.encode(args.channel, args.frame.encode(), args.timestamp)

    # Print the encoded frame (final packet)
    print(repr(encoded_frame))

if __name__ == "__main__":
    main()
