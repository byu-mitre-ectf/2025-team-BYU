import argparse
import struct
import json
from Crypto.Cipher import ChaCha20_Poly1305
from Crypto.Random import get_random_bytes

class Encoder:
    def __init__(self, secrets: bytes):
        """
        You **may not** change the arguments or returns of this function!

        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        """
        # Load the JSON from the secrets file
        secrets = json.loads(secrets)
        
        # self.channel_keys["0"] would output the valid channel key
        self.channel_keys = secrets["channel_keys"]  

    def encode(self, channel: int, frame: bytes, timestamp: int) -> bytes:
        """The frame encoder function

        This will be called for every frame that needs to be encoded before being
        transmitted by the satellite to all listening TVs

        You **may not** change the arguments or returns of this function!

        :param channel: 16b unsigned channel number. Channel 0 is the emergency
            broadcast that must be decodable by all channels.
        :param frame: Frame to encode. Max frame size is 64 bytes.
        :param timestamp: 64b timestamp to use for encoding. **NOTE**: This value may
            have no relation to the current timestamp, so you should not compare it
            against the current time. The timestamp is guaranteed to strictly
            monotonically increase (always go up) with subsequent calls to encode

        :returns: The encoded frame, which will be sent to the Decoder
        """

        # Start by validating all inputs. Throw an appropriate error when needed
        # Ensures a frame is equal to or over 64 bytes
        if len(frame) > 64:
            raise ValueError("Frame size exceeds 64 bytes!")
        # Ensures that the channel number is between 0 and 8
        if not (0 <= channel <= 8):
            raise ValueError("Channel number must be an unsigned int between 0 and 8!")
        # Ensures that the timestamp is an unsigned long long int
        if not (0 <= timestamp <= (2**64 - 1)):
            raise ValueError("Timestamp must be an unsigned long long integer!")

        # Creates a packet from the timestamp and frame data
        packet = struct.pack("<Q", timestamp) + frame

        # Reads the key for the channel
        if str(channel) not in self.channel_keys:
            raise ValueError(f"No key found for channel {channel}!")

        # Gets the key for a specific channel, and converts the key from a string into bytes
        key = bytes.fromhex(self.channel_keys[str(channel)])

        # Generate a random 12 byte nonce for the encryption
        # ChaCha20-Poly1305 can use a 12-byte nonce
        nonce = get_random_bytes(12)

        # Encrypt the packet using ChaCha20-Poly1305
        cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce)
        cipher.update(struct.pack("<I", channel) + nonce)

        # Turns the packet into ciphertext, and also creates a tag associated with it (ty random chinese guy)
        ciphertext, tag = cipher.encrypt_and_digest(packet)

        # Construct the final packet with the channel number, the nonce, the ciphertext, and the tag
        final_packet = struct.pack("<I", channel) + nonce + tag + ciphertext

        # "sends" the final packet
        return final_packet


def main():
    """A test main to one-shot encode a frame

    This function is only for your convenience and will not be used in the final design.

    After pip-installing, you should be able to call this with:
        python3 -m ectf25_design.encoder path/to/test.secrets 1 "frame to encode" 100
    """
    parser = argparse.ArgumentParser(prog="ectf25_design.encoder")
    parser.add_argument(
        "secrets_file", type=argparse.FileType("rb"), help="Path to the secrets file"
    )
    parser.add_argument("channel", type=int, help="Channel to encode for")
    parser.add_argument("frame", help="Contents of the frame")
    parser.add_argument("timestamp", type=int, help="64b timestamp to use")
    args = parser.parse_args()

    encoder = Encoder(args.secrets_file.read())
    encoded_frame = encoder.encode(args.channel, args.frame.encode(), args.timestamp)
    print(repr(encoded_frame))


if __name__ == "__main__":
    main()
